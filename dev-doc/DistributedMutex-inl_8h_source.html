<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>autotier: src/rocksdb/third-party/folly/folly/synchronization/DistributedMutex-inl.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">autotier
   </div>
   <div id="projectbrief">Automatic Tiering Fuse Filesystem</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ab48de68820f4f2b1558159a0a2d81e2.html">src</a></li><li class="navelem"><a class="el" href="dir_2f54fadb1cb00ea24234c3272e3c1393.html">rocksdb</a></li><li class="navelem"><a class="el" href="dir_fa1787a53da3a14eace44b4c5e8d372a.html">third-party</a></li><li class="navelem"><a class="el" href="dir_23087404fe6e16949a72cf1e00b6507a.html">folly</a></li><li class="navelem"><a class="el" href="dir_329ed89cee7fff2f37b2938076f6b3f7.html">folly</a></li><li class="navelem"><a class="el" href="dir_99f5ed04131b3293e6e98b5334f6b53e.html">synchronization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DistributedMutex-inl.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//  This source code is licensed under both the GPLv2 (found in the</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//  COPYING file in the root directory) and Apache 2.0 License</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//  (found in the LICENSE.Apache file in the root directory).</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#include &lt;folly/synchronization/DistributedMutex.h&gt;</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#include &lt;folly/ConstexprMath.h&gt;</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &lt;folly/Portability.h&gt;</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;folly/ScopeGuard.h&gt;</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;folly/Utility.h&gt;</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;folly/chrono/Hardware.h&gt;</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &lt;folly/detail/Futex.h&gt;</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &lt;folly/lang/Align.h&gt;</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &lt;folly/lang/Bits.h&gt;</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &lt;folly/portability/Asm.h&gt;</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &lt;folly/synchronization/AtomicNotification.h&gt;</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &lt;folly/synchronization/AtomicUtil.h&gt;</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;folly/synchronization/detail/InlineFunctionRef.h&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;folly/synchronization/detail/Sleeper.h&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &lt;cstddef&gt;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &lt;stdexcept&gt;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="keyword">namespace </span>folly {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="keyword">namespace </span>detail {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="keyword">namespace </span>distributed_mutex {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">// kUnlocked is used to show unlocked state</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// When locking threads encounter kUnlocked in the underlying storage, they</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// can just acquire the lock without any further effort</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;constexpr <span class="keyword">auto</span> kUnlocked = std::uintptr_t{0b0};</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// kLocked is used to show that the mutex is currently locked, and future</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// attempts to lock the mutex should enqueue on the central storage</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">// Locking threads find this on central storage only when there is a</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// contention chain that is undergoing wakeups, in every other case, a locker</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">// will either find kUnlocked or an arbitrary address with the kLocked bit set</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;constexpr <span class="keyword">auto</span> kLocked = std::uintptr_t{0b1};</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">// kTimedWaiter is set when there is at least one timed waiter on the mutex</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">// Timed waiters do not follow the sleeping strategy employed by regular,</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">// non-timed threads.  They sleep on the central mutex atomic through an</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">// extended futex() interface that allows sleeping with the same semantics for</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">// non-standard integer widths</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// When a regular non-timed thread unlocks or enqueues on the mutex, and sees</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">// a timed waiter, it takes ownership of all the timed waiters.  The thread</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">// that has taken ownership of the timed waiter releases the timed waiters</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">// when it gets a chance at the critical section.  At which point it issues a</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// wakeup to single timed waiter, timed waiters always issue wake() calls to</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">// other timed waiters</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;constexpr <span class="keyword">auto</span> kTimedWaiter = std::uintptr_t{0b10};</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; </div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">// kUninitialized means that the thread has just enqueued, and has not yet</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">// gotten to initializing itself with the address of its successor</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">// this becomes significant for threads that are trying to wake up the</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">// uninitialized thread, if they see that the thread is not yet initialized,</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">// they can do nothing but spin, and wait for the thread to get initialized</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">// This also plays a role in the functioning of flat combining as implemented</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">// in DistributedMutex.  When a thread owning the lock goes through the</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">// contention chain to either unlock the mutex or combine critical sections</span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">// from the other end.  The presence of kUninitialized means that the</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">// combining thread is not able to make progress after this point.  So we</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">// transfer the lock.</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;constexpr <span class="keyword">auto</span> kUninitialized = std::uint32_t{0b0};</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">// kWaiting will be set in the waiter&#39;s futex structs while they are spinning</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">// while waiting for the mutex</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;constexpr <span class="keyword">auto</span> kWaiting = std::uint32_t{0b1};</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">// kWake will be set by threads that are waking up waiters that have enqueued</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;constexpr <span class="keyword">auto</span> kWake = std::uint32_t{0b10};</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">// kSkipped will be set by a waker when they see that a waiter has been</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">// preempted away by the kernel, in this case the thread that got skipped will</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">// have to wake up and put itself back on the queue</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;constexpr <span class="keyword">auto</span> kSkipped = std::uint32_t{0b11};</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">// kAboutToWait will be set by a waiter that enqueues itself with the purpose</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">// of waiting on a futex</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;constexpr <span class="keyword">auto</span> kAboutToWait = std::uint32_t{0b100};</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">// kSleeping will be set by a waiter right before enqueueing on a futex.  When</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">// a thread wants to wake up a waiter that has enqueued on a futex, it should</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">// set the futex to contain kWake</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">// a thread that is unlocking and wants to skip over a sleeping thread also</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">// calls futex_.exchange(kSleeping) on the sleeping thread&#39;s futex word.  It</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">// does this to 1. detect whether the sleeping thread had actually gone to</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">// sleeping on the futex word so it can skip it, and 2. to synchronize with</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">// other non atomic writes in the sleeping thread&#39;s context (such as the write</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">// to track the next waiting thread).</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">// We reuse kSleeping instead of say using another constant kEarlyDelivery to</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">// avoid situations where a thread has to enter kernel mode due to calling</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">// futexWait() twice because of the presence of a waking thread.  This</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">// situation can arise when an unlocking thread goes to skip over a sleeping</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">// thread, sees that the thread has slept and move on, but the sleeping thread</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">// had not yet entered futex().  This interleaving causes the thread calling</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">// futex() to return spuriously, as the futex word is not what it should be</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;constexpr <span class="keyword">auto</span> kSleeping = std::uint32_t{0b101};</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">// kCombined is set by the lock holder to let the waiter thread know that its</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">// combine request was successfully completed by the lock holder.  A</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">// successful combine means that the thread requesting the combine operation</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">// does not need to unlock the mutex; in fact, doing so would be an error.</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;constexpr <span class="keyword">auto</span> kCombined = std::uint32_t{0b111};</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">// kCombineUninitialized is like kUninitialized but is set by a thread when it</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">// enqueues in hopes of getting its critical section combined with the lock</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">// holder</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;constexpr <span class="keyword">auto</span> kCombineUninitialized = std::uint32_t{0b1000};</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">// kCombineWaiting is set by a thread when it is ready to have its combine</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">// record fulfilled by the lock holder.  In particular, this signals to the</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">// lock holder that the thread has set its next_ pointer in the contention</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">// chain</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;constexpr <span class="keyword">auto</span> kCombineWaiting = std::uint32_t{0b1001};</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">// kExceptionOccurred is set on the waiter futex when the remote task throws</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">// an exception.  It is the caller&#39;s responsibility to retrieve the exception</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">// and rethrow it in their own context.  Note that when the caller uses a</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">// noexcept function as their critical section, they can avoid checking for</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">// this value</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">// This allows us to avoid all cost of exceptions in the memory layout of the</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">// fast path (no errors) as exceptions are stored as an std::exception_ptr in</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">// the same union that stores the return value of the critical section.  We</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">// also avoid all CPU overhead because the combiner uses a try-catch block</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">// without any additional branching to handle exceptions</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;constexpr <span class="keyword">auto</span> kExceptionOccurred = std::uint32_t{0b1010};</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160; </div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">// The number of spins that we are allowed to do before we resort to marking a</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">// thread as having slept</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">// This is just a magic number from benchmarks</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;constexpr <span class="keyword">auto</span> kScheduledAwaySpinThreshold = std::chrono::nanoseconds{200};</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment">// The maximum number of spins before a thread starts yielding its processor</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment">// in hopes of getting skipped</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;constexpr <span class="keyword">auto</span> kMaxSpins = 4000;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">// The maximum number of contention chains we can resolve with flat combining.</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">// After this number of contention chains, the mutex falls back to regular</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">// two-phased mutual exclusion to ensure that we don&#39;t starve the combiner</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">// thread</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;constexpr <span class="keyword">auto</span> kMaxCombineIterations = 2;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160; </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic&gt;</div>
<div class="line"><a name="l00153"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">  153</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">WakerMetadata</a> {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">WakerMetadata</a>(</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      std::uintptr_t waker = 0,</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      std::uintptr_t waiters = 0,</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      std::uint32_t sleeper = kUninitialized)</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    : waker_{waker}, waiters_{waiters}, sleeper_{sleeper} {}</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160; </div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="comment">// This is the thread that initiated wakeups for the contention chain.</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  <span class="comment">// There can only ever be one thread that initiates the wakeup for a</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  <span class="comment">// chain in the spin only version of this mutex.  When a thread that just</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// woke up sees this as the next thread to wake up, it knows that it is the</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="comment">// terminal node in the contention chain.  This means that it was the one</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="comment">// that took off the thread that had acquired the mutex off the centralized</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="comment">// state.  Therefore, the current thread is the last in its contention</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="comment">// chain.  It will fall back to centralized storage to pick up the next</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="comment">// waiter or release the mutex</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  <span class="comment">// When we move to a full sleeping implementation, this might need to change</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="comment">// to a small_vector&lt;&gt; to account for failed wakeups, or we can put threads</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="comment">// to sleep on the central futex, which is an easier implementation</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="comment">// strategy.  Although, since this is allocated on the stack, we can set a</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="comment">// prohitively large threshold to avoid heap allocations, this strategy</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// however, might cause increased cache misses on wakeup signalling</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  std::uintptr_t waker_{0};</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="comment">// the list of threads that the waker had previously seen to be sleeping on</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="comment">// a futex(),</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="comment">// this is given to the current thread as a means to pass on</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  <span class="comment">// information.  When the current thread goes to unlock the mutex and does</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="comment">// not see contention, it should go and wake up the head of this list.  If</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="comment">// the current thread sees a contention chain on the mutex, it should pass</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  <span class="comment">// on this list to the next thread that gets woken up</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  std::uintptr_t waiters_{0};</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="comment">// The futex that this waiter will sleep on</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="comment">// how can we reuse futex_ from above for futex management?</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  Futex&lt;Atomic&gt; sleeper_{kUninitialized};</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;};</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160; </div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="keyword">using</span> <a class="code" href="classfolly_1_1detail_1_1InlineFunctionRef.html">CombineFunction</a> = <a class="code" href="classfolly_1_1detail_1_1InlineFunctionRef.html">detail::InlineFunctionRef</a>&lt;void(), 48&gt;;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic&gt;</div>
<div class="line"><a name="l00213"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">  213</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a> {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>() {}</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>(<span class="keyword">const</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp; operator=(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160; </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <span class="keywordtype">void</span> initialize(std::uint64_t futex, <a class="code" href="classfolly_1_1detail_1_1InlineFunctionRef.html">CombineFunction</a> task) {</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">// we only initialize the function if we were actually given a non-null</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">// task, otherwise</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">if</span> (task) {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      assert(futex == kCombineUninitialized);</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      <span class="keyword">new</span> (&amp;function_) <a class="code" href="classfolly_1_1detail_1_1InlineFunctionRef.html">CombineFunction</a>(task);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      assert((futex == kUninitialized) || (futex == kAboutToWait));</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      <span class="keyword">new</span> (&amp;metadata_) <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">WakerMetadata&lt;Atomic&gt;</a>{};</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    }</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160; </div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="comment">// this pedantic store is needed to ensure that the waking thread</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="comment">// synchronizes with the state in the waiter struct when it loads the</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="comment">// value of the futex word</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="comment">// on x86, this gets optimized away to just a regular store, it might be</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="comment">// needed on platforms where explicit acquire-release barriers are</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="comment">// required for synchronization</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="comment">// note that we release here at the end of the constructor because</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    <span class="comment">// construction is complete here, any thread that acquires this release</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="comment">// will see a well constructed wait node</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    futex_.store(futex, std::memory_order_release);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  }</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160; </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  std::array&lt;std::uint8_t, hardware_destructive_interference_size&gt; padding1;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="comment">// the atomic that this thread will spin on while waiting for the mutex to</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="comment">// be unlocked</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="keyword">alignas</span>(hardware_destructive_interference_size) Atomic&lt;std::uint64_t&gt; futex_{</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      kUninitialized};</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">// The successor of this node.  This will be the thread that had its address</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// on the mutex previously</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="comment">// We can do without making this atomic since the remote thread synchronizes</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="comment">// on the futex variable above.  If this were not atomic, the remote thread</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">// would only be allowed to read from it after the waiter has moved into the</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="comment">// waiting state to avoid risk of a load racing with a write.  However, it</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="comment">// helps to make this atomic because we can use an unconditional load and make</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="comment">// full use of the load buffer to coalesce both reads into a single clock</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="comment">// cycle after the line arrives in the combiner core.  This is a heavily</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// contended line, so an RFO from the enqueueing thread is highly likely and</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  <span class="comment">// has the potential to cause an immediate invalidation; blocking the combiner</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="comment">// thread from making progress until the line is pulled back to read this</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <span class="comment">// value</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">// Further, making this atomic prevents the compiler from making an incorrect</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="comment">// optimization where it does not load the value as written in the code, but</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <span class="comment">// rather dereferences it through a pointer whenever needed (since the value</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="comment">// of the pointer to this is readily available on the stack).  Doing this</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <span class="comment">// causes multiple invalidation requests from the enqueueing thread, blocking</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="comment">// remote progress</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// Note that we use relaxed loads and stores, so this should not have any</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  <span class="comment">// additional overhead compared to a regular load on most architectures</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  std::atomic&lt;std::uintptr_t&gt; next_{0};</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  <span class="comment">// We use an anonymous union for the combined critical section request and</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="comment">// the metadata that will be filled in from the leader&#39;s end.  Only one is</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="comment">// active at a time - if a leader decides to combine the requested critical</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="comment">// section into its execution, it will not touch the metadata field.  If a</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">// leader decides to migrate the lock to the waiter, it will not touch the</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">// function</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// this allows us to transfer more state when combining a critical section</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="comment">// and reduce the cache misses originating from executing an arbitrary</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="comment">// lambda</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="comment">// note that this is an anonymous union, not an unnamed union, the members</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <span class="comment">// leak into the surrounding scope</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="keyword">union </span>{</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="comment">// metadata for the waker</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">WakerMetadata&lt;Atomic&gt;</a> metadata_;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="comment">// The critical section that can potentially be combined into the critical</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="comment">// section of the locking thread</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="comment">// This is kept as a FunctionRef because the original function is preserved</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="comment">// until the lock_combine() function returns.  A consequence of using</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="comment">// FunctionRef here is that we don&#39;t need to do any allocations and can</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="comment">// allow users to capture unbounded state into the critical section.  Flat</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="comment">// combining means that the user does not have access to the thread</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="comment">// executing the critical section, so assumptions about thread local</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="comment">// references can be invalidated.  Being able to capture arbitrary state</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">// allows the user to do thread local accesses right before the critical</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="comment">// section and pass them as state to the callable being referenced here</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <a class="code" href="classfolly_1_1detail_1_1InlineFunctionRef.html">CombineFunction</a> function_;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="comment">// The user is allowed to use a combined critical section that returns a</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="comment">// value.  This buffer is used to implement the value transfer to the</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="comment">// waiting thread.  We reuse the same union because this helps us combine</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="comment">// one synchronization operation with a material value transfer.</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">// The waker thread needs to synchronize on this cacheline to issue a</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="comment">// wakeup to the waiter, meaning that the entire line needs to be pulled</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">// into the remote core in exclusive mode.  So we reuse the coherence</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="comment">// operation to transfer the return value in addition to the</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <span class="comment">// synchronization signal.  In the case that the user&#39;s data item is</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="comment">// small, the data is transferred all inline as part of the same line,</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="comment">// which pretty much arrives into the CPU cache in the same clock cycle or</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    <span class="comment">// two after a read-for-ownership request.  This gives us a high chance of</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="comment">// coalescing the entire transitive store buffer together into one cache</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <span class="comment">// coherence operation from the waker&#39;s end.  This allows us to make use</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="comment">// of the CPU bus bandwidth which would have otherwise gone to waste.</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <span class="comment">// Benchmarks prove this theory under a wide range of contention, value</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="comment">// sizes, NUMA interactions and processor models</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">// The current version of the Intel optimization manual confirms this</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="comment">// theory somewhat as well in section 2.3.5.1 (Load and Store Operation</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="comment">// Overview)</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="comment">//    When an instruction writes data to a memory location [...], the</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    <span class="comment">//    processor ensures that it has the line containing this memory location</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="comment">//    is in its L1d cache [...]. If the cache line is not there, it fetches</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="comment">//    from the next levels using a RFO request [...] RFO and storing the</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">//    data happens after instruction retirement.  Therefore, the store</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">//    latency usually does not affect the store instruction itself</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="comment">// This gives the user the ability to input up to 48 bytes into the</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="comment">// combined critical section through an InlineFunctionRef and output 48</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="comment">// bytes from it basically without any cost.  The type of the entity</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">// stored in the buffer has to be matched by the type erased callable that</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    <span class="comment">// the caller has used.  At this point, the caller is still in the</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// template instantiation leading to the combine request, so it has</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="comment">// knowledge of the return type and can apply the appropriate</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="comment">// reinterpret_cast and launder operation to safely retrieve the data from</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="comment">// this buffer</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    _t&lt;std::aligned_storage&lt;48, 8&gt;&gt; storage_;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  };</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  std::array&lt;std::uint8_t, hardware_destructive_interference_size&gt; padding2;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;};</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160; </div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><a name="l00359"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html">  359</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html">RequestWithReturn</a> {</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="keyword">using</span> F = Func;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keyword">using</span> ReturnType = decltype(std::declval&lt;const Func&amp;&gt;()());</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html">RequestWithReturn</a>(Func func) : func_{std::move(func)} {}</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160; </div>
<div class="line"><a name="l00375"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a6bd39a45c63e30b809e89aaf7ea09006">  375</a></span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a6bd39a45c63e30b809e89aaf7ea09006">~RequestWithReturn</a>() {}</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160; </div>
<div class="line"><a name="l00382"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a8a5a64f50deec551cc048b7e6760aca8">  382</a></span>&#160;  ReturnType <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a8a5a64f50deec551cc048b7e6760aca8">get</a>() &amp;&amp; {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="comment">// when the return value has been processed, we destroy the value</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="comment">// contained in this request.  Using a scope_exit means that we don&#39;t have</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="comment">// to worry about storing the value somewhere and causing potentially an</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">// extra move</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">// note that the invariant here is that this function is only called if the</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">// requesting thread had it&#39;s critical section combined, and the value_</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// member constructed through detach()</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    SCOPE_EXIT {</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      value_.~ReturnType();</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    };</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="keywordflow">return</span> std::move(value_);</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  }</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160; </div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  <span class="comment">// this contains a copy of the function the waiter had requested to be</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="comment">// executed as a combined critical section</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  Func func_;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="comment">// this stores the return value used in the request, we use a union here to</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  <span class="comment">// avoid laundering and allow return types that are not default</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="comment">// constructible to be propagated through the execution of the critical</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  <span class="comment">// section</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  <span class="comment">// note that this is an anonymous union, the member leaks into the</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  <span class="comment">// surrounding scope as a member variable</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;  <span class="keyword">union </span>{</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    ReturnType value_;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  };</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;};</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160; </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><a name="l00413"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html">  413</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html">RequestWithoutReturn</a> {</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="keyword">using</span> F = Func;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="keyword">using</span> ReturnType = void;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html">RequestWithoutReturn</a>(Func func) : func_{std::move(func)} {}</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160; </div>
<div class="line"><a name="l00423"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html#af2f50de7ca9cafad035e5d5c99673b6b">  423</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html#af2f50de7ca9cafad035e5d5c99673b6b">get</a>() &amp;&amp; {}</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; </div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  <span class="comment">// this contains a copy of the function the waiter had requested to be</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  <span class="comment">// executed as a combined critical section</span></div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;  Func func_;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;};</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160; </div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment">// we need to use std::integral_constant::value here as opposed to</span></div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment">// std::integral_constant::operator T() because MSVC errors out with the</span></div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment">// implicit conversion</span></div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="keyword">using</span> Request = _t&lt;std::conditional&lt;</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    std::is_void&lt;decltype(std::declval&lt;const Func&amp;&gt;()())&gt;::value,</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    RequestWithoutReturn&lt;Func&gt;,</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    RequestWithReturn&lt;Func&gt;&gt;&gt;;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; </div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00467"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce.html">  467</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce.html">TaskWithCoalesce</a> {</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="keyword">using</span> ReturnType = decltype(std::declval&lt;const Func&amp;&gt;()());</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  <span class="keyword">using</span> <a class="code" href="structfolly_1_1Unit.html">StorageType</a> = <a class="code" href="structfolly_1_1Unit.html">folly::Unit</a>;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce.html">TaskWithCoalesce</a>(Func func, <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp; waiter)</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;      : func_{std::move(func)}, waiter_(waiter) {}</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160; </div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <span class="keywordtype">void</span> operator()()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="keyword">auto</span> value = func_();</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keyword">new</span> (&amp;waiter_.storage_) ReturnType(std::move(value));</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  }</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160; </div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  Func func_;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp; waiter_;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160; </div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  static_assert(!std::is_void&lt;ReturnType&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  static_assert(<span class="keyword">alignof</span>(decltype(waiter_.storage_)) &gt;= <span class="keyword">alignof</span>(ReturnType), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  static_assert(<span class="keyword">sizeof</span>(decltype(waiter_.storage_)) &gt;= <span class="keyword">sizeof</span>(ReturnType), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;};</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160; </div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00489"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce.html">  489</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce.html">TaskWithoutCoalesce</a> {</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="keyword">using</span> ReturnType = void;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  <span class="keyword">using</span> <a class="code" href="structfolly_1_1Unit.html">StorageType</a> = <a class="code" href="structfolly_1_1Unit.html">folly::Unit</a>;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce.html">TaskWithoutCoalesce</a>(Func func, <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;) : func_{std::move(func)} {}</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160; </div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="keywordtype">void</span> operator()()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    func_();</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  }</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160; </div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;  Func func_;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;};</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; </div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00504"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue.html">  504</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue.html">TaskWithBigReturnValue</a> {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  <span class="comment">// Using storage that is aligned on the cacheline boundary helps us avoid a</span></div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  <span class="comment">// situation where the data ends up being allocated on two separate</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  <span class="comment">// cachelines.  This would require the remote thread to pull in both lines</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="comment">// to issue a write.</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;  <span class="comment">// We also isolate the storage by appending some padding to the end to</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  <span class="comment">// ensure we avoid false-sharing with the metadata used while the waiter</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  <span class="comment">// waits</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  <span class="keyword">using</span> ReturnType = decltype(std::declval&lt;const Func&amp;&gt;()());</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> kReturnValueAlignment = folly::kIsMsvc</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      ? 8</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      : folly::constexpr_max(</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            <span class="keyword">alignof</span>(ReturnType),</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;            folly::hardware_destructive_interference_size);</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  <span class="keyword">using</span> StorageType = _t&lt;std::aligned_storage&lt;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <span class="keyword">sizeof</span>(</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;          _t&lt;std::aligned_storage&lt;<span class="keyword">sizeof</span>(ReturnType), kReturnValueAlignment&gt;&gt;),</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;      kReturnValueAlignment&gt;&gt;;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160; </div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;  <span class="keyword">explicit</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue.html">TaskWithBigReturnValue</a>(Func func, <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;)</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;      : func_{std::move(func)} {}</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160; </div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;  <span class="keywordtype">void</span> operator()()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    assert(storage_);</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    <span class="keyword">auto</span> value = func_();</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keyword">new</span> (storage_) ReturnType(std::move(value));</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160; </div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  <span class="keywordtype">void</span> attach(StorageType* storage) {</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    assert(!storage_);</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    storage_ = storage;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  }</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160; </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160; <span class="keyword">private</span>:</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  Func func_;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  StorageType* storage_{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160; </div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  static_assert(!std::is_void&lt;ReturnType&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  static_assert(<span class="keyword">sizeof</span>(Waiter::storage_) &lt; <span class="keyword">sizeof</span>(ReturnType), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;};</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160; </div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span>&gt;</div>
<div class="line"><a name="l00548"></a><span class="lineno"><a class="line" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">  548</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">Sizeof_</a>;</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00550"></a><span class="lineno"><a class="line" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof___3_01T_00_01false_01_4.html">  550</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">Sizeof_</a>&lt;T, false&gt; : std::integral_constant&lt;std::size_t, sizeof(T)&gt; {};</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00552"></a><span class="lineno"><a class="line" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof___3_01T_00_01true_01_4.html">  552</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">Sizeof_</a>&lt;T, true&gt; : std::integral_constant&lt;std::size_t, 0&gt; {};</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00554"></a><span class="lineno"><a class="line" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof.html">  554</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof.html">Sizeof</a> : <a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">Sizeof_</a>&lt;T, std::is_void&lt;T&gt;::value&gt; {};</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160; </div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">// we need to use std::integral_constant::value here as opposed to</span></div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">// std::integral_constant::operator T() because MSVC errors out with the</span></div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">// implicit conversion</span></div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="keyword">using</span> CoalescedTask = _t&lt;std::conditional&lt;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    std::is_void&lt;decltype(std::declval&lt;const Func&amp;&gt;()())&gt;::value,</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce.html">TaskWithoutCoalesce&lt;Func, Waiter&gt;</a>,</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    _t&lt;std::conditional&lt;</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <a class="code" href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof.html">Sizeof&lt;decltype(std::declval&lt;const Func&amp;&gt;</a>()())&gt;::value &lt;=</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;            <span class="keyword">sizeof</span>(Waiter::storage_),</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce.html">TaskWithCoalesce&lt;Func, Waiter&gt;</a>,</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;        <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue.html">TaskWithBigReturnValue&lt;Func, Waiter&gt;</a>&gt;&gt;&gt;&gt;;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160; </div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;std::nullptr_t coalesce(std::nullptr_t&amp;, <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter</a>&amp;) {</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;}</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160; </div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="keyword">template</span> &lt;</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="keyword">typename</span> Request,</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keyword">typename</span> Waiter,</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    <span class="keyword">typename</span> Func = <span class="keyword">typename</span> Request::F&gt;</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;CoalescedTask&lt;Func, Waiter&gt; coalesce(Request&amp; request, Waiter&amp; waiter) {</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  static_assert(!std::is_same&lt;Request, std::nullptr_t&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  <span class="keywordflow">return</span> CoalescedTask&lt;Func, Waiter&gt;{request.func_, waiter};</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;}</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160; </div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="keyword">inline</span> std::nullptr_t makeReturnValueStorageFor(std::nullptr_t&amp;) {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;}</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160; </div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="keyword">template</span> &lt;</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    <span class="keyword">typename</span> CoalescedTask,</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    <span class="keyword">typename</span> StorageType = <span class="keyword">typename</span> CoalescedTask::StorageType&gt;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;StorageType makeReturnValueStorageFor(CoalescedTask&amp;) {</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;}</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160; </div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Task, <span class="keyword">typename</span> Storage&gt;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="keywordtype">void</span> attach(Task&amp;, Storage&amp;) {</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  static_assert(</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;      std::is_same&lt;Storage, std::nullptr_t&gt;{} ||</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;          std::is_same&lt;Storage, folly::Unit&gt;{},</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;}</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160; </div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="keyword">template</span> &lt;</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="keyword">typename</span> R,</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="keyword">typename</span> W,</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    <span class="keyword">typename</span> StorageType = <span class="keyword">typename</span> TaskWithBigReturnValue&lt;R, W&gt;::StorageType&gt;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="keywordtype">void</span> attach(TaskWithBigReturnValue&lt;R, W&gt;&amp; task, StorageType&amp; storage) {</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  task.attach(&amp;storage);</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;}</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160; </div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Request, <span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="keywordtype">void</span> throwIfExceptionOccurred(Request&amp;, Waiter&amp; waiter, <span class="keywordtype">bool</span> exception) {</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;  <span class="keyword">using</span> Storage = decltype(waiter.storage_);</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  <span class="keyword">using</span> F = <span class="keyword">typename</span> Request::F;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;  static_assert(<span class="keyword">sizeof</span>(Storage) &gt;= <span class="keyword">sizeof</span>(std::exception_ptr), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  static_assert(<span class="keyword">alignof</span>(Storage) &gt;= <span class="keyword">alignof</span>(std::exception_ptr), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160; </div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="comment">// we only need to check for an exception in the waiter struct if the passed</span></div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <span class="comment">// callable is not noexcept</span></div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  <span class="comment">// we need to make another instance of the exception with automatic storage</span></div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <span class="comment">// duration and destroy the exception held in the storage *before throwing* to</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="comment">// avoid leaks.  If we don&#39;t destroy the exception_ptr in storage, the</span></div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  <span class="comment">// refcount for the internal exception will never hit zero, thereby leaking</span></div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="comment">// memory</span></div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keywordflow">if</span> ((!noexcept(std::declval&lt;const F&amp;&gt;()()) &amp;&amp; exception)) {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <span class="keyword">auto</span> storage = &amp;waiter.storage_;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keyword">auto</span> exc = folly::launder(<span class="keyword">reinterpret_cast&lt;</span>std::exception_ptr*<span class="keyword">&gt;</span>(storage));</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    <span class="keyword">auto</span> copy = std::move(*exc);</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    exc-&gt;std::exception_ptr::~exception_ptr();</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    std::rethrow_exception(std::move(copy));</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  }</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;}</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160; </div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="keywordtype">void</span> detach(std::nullptr_t&amp;, Waiter&amp;, <span class="keywordtype">bool</span> exception, std::nullptr_t&amp;) {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  assert(!exception);</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;}</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160; </div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter, <span class="keyword">typename</span> F&gt;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="keywordtype">void</span> detach(</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    RequestWithoutReturn&lt;F&gt;&amp; request,</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    Waiter&amp; waiter,</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    <span class="keywordtype">bool</span> exception,</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <a class="code" href="structfolly_1_1Unit.html">folly::Unit</a>&amp;) {</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  throwIfExceptionOccurred(request, waiter, exception);</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;}</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160; </div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter, <span class="keyword">typename</span> F&gt;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="keywordtype">void</span> detach(</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    RequestWithReturn&lt;F&gt;&amp; request,</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    Waiter&amp; waiter,</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordtype">bool</span> exception,</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    <a class="code" href="structfolly_1_1Unit.html">folly::Unit</a>&amp;) {</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  throwIfExceptionOccurred(request, waiter, exception);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160; </div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> RequestWithReturn&lt;F&gt;::ReturnType;</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  static_assert(!std::is_same&lt;ReturnType, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  static_assert(<span class="keyword">sizeof</span>(waiter.storage_) &gt;= <span class="keyword">sizeof</span>(ReturnType), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160; </div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  <span class="keyword">auto</span>&amp; val = *folly::launder(<span class="keyword">reinterpret_cast&lt;</span>ReturnType*<span class="keyword">&gt;</span>(&amp;waiter.storage_));</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  <span class="keyword">new</span> (&amp;request.value_) ReturnType(std::move(val));</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  val.~ReturnType();</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;}</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160; </div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter, <span class="keyword">typename</span> F, <span class="keyword">typename</span> Storage&gt;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="keywordtype">void</span> detach(</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    RequestWithReturn&lt;F&gt;&amp; request,</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;    Waiter&amp; waiter,</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    <span class="keywordtype">bool</span> exception,</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;    Storage&amp; storage) {</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  throwIfExceptionOccurred(request, waiter, exception);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160; </div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;  <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> RequestWithReturn&lt;F&gt;::ReturnType;</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  static_assert(!std::is_same&lt;ReturnType, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  static_assert(<span class="keyword">sizeof</span>(storage) &gt;= <span class="keyword">sizeof</span>(ReturnType), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160; </div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  <span class="keyword">auto</span>&amp; val = *folly::launder(<span class="keyword">reinterpret_cast&lt;</span>ReturnType*<span class="keyword">&gt;</span>(&amp;storage));</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  <span class="keyword">new</span> (&amp;request.value_) ReturnType(std::move(val));</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  val.~ReturnType();</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160; </div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="keyword">inline</span> std::chrono::nanoseconds time() {</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  <span class="keywordflow">return</span> std::chrono::nanoseconds{hardware_timestamp()};</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;}</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160; </div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;Type* extractPtr(std::uintptr_t from) {</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  <span class="comment">// shift one bit off the end, to get all 1s followed by a single 0</span></div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  <span class="keyword">auto</span> mask = std::numeric_limits&lt;std::uintptr_t&gt;::max();</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  mask &gt;&gt;= 1;</div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  mask &lt;&lt;= 1;</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;  assert(!(mask &amp; 0b1));</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160; </div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  <span class="keywordflow">return</span> folly::bit_cast&lt;Type*&gt;(from &amp; mask);</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;}</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160; </div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="keyword">inline</span> std::uint64_t strip(std::chrono::nanoseconds t) {</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;  <span class="keyword">auto</span> time = t.count();</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::uint64_t<span class="keyword">&gt;</span>(time) &lt;&lt; 8;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;}</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160; </div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="keyword">inline</span> std::uint64_t recover(std::uint64_t from) {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  <span class="keywordflow">return</span> from &gt;&gt; 8;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;}</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160; </div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l00753"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">  753</a></span>&#160;<span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt;Atomic, TimePublishing&gt;::<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a> {</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  <span class="comment">// DistributedMutexStateProxy is move constructible and assignable for</span></div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  <span class="comment">// convenience</span></div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&amp;&amp; other) {</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    *<span class="keyword">this</span> = std::move(other);</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;  }</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160; </div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&amp; operator=(<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>&amp;&amp; other) {</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    assert(!(*<span class="keyword">this</span>));</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160; </div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    next_ = folly::exchange(other.next_, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    expected_ = folly::exchange(other.expected_, 0);</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    timedWaiters_ = folly::exchange(other.timedWaiters_, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    combined_ = folly::exchange(other.combined_, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    waker_ = folly::exchange(other.waker_, 0);</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    waiters_ = folly::exchange(other.waiters_, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    ready_ = folly::exchange(other.ready_, <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160; </div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  }</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160; </div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="comment">// The proxy is valid when a mutex acquisition attempt was successful,</span></div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  <span class="comment">// lock() is guaranteed to return a valid proxy, try_lock() is not</span></div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> bool()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    <span class="keywordflow">return</span> expected_;</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  }</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160; </div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  <span class="comment">// private:</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <span class="comment">// friend the mutex class, since that will be accessing state private to</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;  <span class="comment">// this class</span></div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex</a>&lt;Atomic, TimePublishing&gt;;</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160; </div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>(</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;      <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* next,</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      std::uintptr_t expected,</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;      <span class="keywordtype">bool</span> timedWaiter = <span class="keyword">false</span>,</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;      <span class="keywordtype">bool</span> combined = <span class="keyword">false</span>,</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;      std::uintptr_t waker = 0,</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;      <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* waiters = <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;      <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* ready = <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;      : next_{next},</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;        expected_{expected},</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        timedWaiters_{timedWaiter},</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        combined_{combined},</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        waker_{waker},</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;        waiters_{waiters},</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        ready_{ready} {}</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160; </div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  <span class="comment">// the next thread that is to be woken up, this being null at the time of</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  <span class="comment">// unlock() shows that the current thread acquired the mutex without</span></div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;  <span class="comment">// contention or it was the terminal thread in the queue of threads waking up</span></div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* next_{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  <span class="comment">// this is the value that the current thread should expect to find on</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  <span class="comment">// unlock, and if this value is not there on unlock, the current thread</span></div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  <span class="comment">// should assume that other threads are enqueued waiting for the mutex</span></div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  <span class="comment">// note that if the mutex has the same state set at unlock time, and this is</span></div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  <span class="comment">// set to an address (and not say kLocked in the case of a terminal waker)</span></div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="comment">// then it must have been the case that no other thread had enqueued itself,</span></div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  <span class="comment">// since threads in the domain of this mutex do not share stack space</span></div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  <span class="comment">// if we want to support stack sharing, we can solve the problem by looping</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  <span class="comment">// at lock time, and setting a variable that says whether we have acquired</span></div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;  <span class="comment">// the lock or not perhaps</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;  std::uintptr_t expected_{0};</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;  <span class="comment">// a boolean that will be set when the mutex has timed waiters that the</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;  <span class="comment">// current thread is responsible for waking, in such a case, the current</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;  <span class="comment">// thread will issue an atomic_notify_one() call after unlocking the mutex</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;  <span class="comment">// note that a timed waiter will itself always have this flag set.  This is</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  <span class="comment">// done so we can avoid having to issue a atomic_notify_all() call (and</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;  <span class="comment">// subsequently a thundering herd) when waking up timed-wait threads</span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;  <span class="keywordtype">bool</span> timedWaiters_{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  <span class="comment">// a boolean that contains true if the state proxy is not meant to be passed</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;  <span class="comment">// to the unlock() function.  This is set only when there is contention and</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;  <span class="comment">// a thread had asked for its critical section to be combined</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;  <span class="keywordtype">bool</span> combined_{<span class="keyword">false</span>};</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;  <span class="comment">// metadata passed along from the thread that woke this thread up</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  std::uintptr_t waker_{0};</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;  <span class="comment">// the list of threads that are waiting on a futex</span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;  <span class="comment">// the current threads is meant to wake up this list of waiters if it is</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  <span class="comment">// able to commit an unlock() on the mutex without seeing a contention chain</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* waiters_{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  <span class="comment">// after a thread has woken up from a futex() call, it will have the rest of</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;  <span class="comment">// the threads that it were waiting behind it in this list, a thread that</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;  <span class="comment">// unlocks has to wake up threads from this list if it has any, before it</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;  <span class="comment">// goes to sleep to prevent pathological unfairness</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;  <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* ready_{<span class="keyword">nullptr</span>};</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;};</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160; </div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l00846"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#aea758280455d5d54df56c2fa1919e4bf">  846</a></span>&#160;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#aea758280455d5d54df56c2fa1919e4bf">DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutex</a>()</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    : state_{kUnlocked} {}</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160; </div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;std::uint64_t publish(</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    std::uint64_t spins,</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    <span class="keywordtype">bool</span>&amp; shouldPublish,</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    std::chrono::nanoseconds&amp; previous,</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    Waiter&amp; waiter,</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    std::uint32_t waitMode) {</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  <span class="comment">// time publishing has some overhead because it executes an atomic exchange on</span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;  <span class="comment">// the futex word.  If this line is in a remote thread (eg.  the combiner),</span></div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  <span class="comment">// then each time we publish a timestamp, this thread has to submit an RFO to</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;  <span class="comment">// the remote core for the cacheline, blocking progress for both threads.</span></div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;  <span class="comment">// the remote core uses a store in the fast path - why then does an RFO make a</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;  <span class="comment">// difference?  The only educated guess we have here is that the added</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;  <span class="comment">// roundtrip delays draining of the store buffer, which essentially exerts</span></div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  <span class="comment">// backpressure on future stores, preventing parallelization</span></div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;  <span class="comment">// if we have requested a combine, time publishing is less important as it</span></div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;  <span class="comment">// only comes into play when the combiner has exhausted their max combine</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;  <span class="comment">// passes.  So we defer time publishing to the point when the current thread</span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;  <span class="comment">// gets preempted</span></div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;  <span class="keyword">auto</span> current = time();</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;  <span class="keywordflow">if</span> ((current - previous) &gt;= kScheduledAwaySpinThreshold) {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    shouldPublish = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;  }</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;  previous = current;</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160; </div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;  <span class="comment">// if we have requested a combine, and this is the first iteration of the</span></div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;  <span class="comment">// wait-loop, we publish a max timestamp to optimistically convey that we have</span></div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <span class="comment">// not yet been preempted (the remote knows the meaning of max timestamps)</span></div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;  <span class="comment">// then if we are under the maximum number of spins allowed before sleeping,</span></div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;  <span class="comment">// we publish the exact timestamp, otherwise we publish the minimum possible</span></div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;  <span class="comment">// timestamp to force the waking thread to skip us</span></div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;  <span class="keyword">auto</span> now = ((waitMode == kCombineWaiting) &amp;&amp; !spins)</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;      ? decltype(time())::max()</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;      : (spins &lt; kMaxSpins) ? previous : decltype(time())::zero();</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160; </div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;  <span class="comment">// the wait mode information is published in the bottom 8 bits of the futex</span></div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;  <span class="comment">// word, the rest contains time information as computed above.  Overflows are</span></div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;  <span class="comment">// not really a correctness concern because time publishing is only a</span></div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;  <span class="comment">// heuristic.  This leaves us 56 bits of nanoseconds (2 years) before we hit</span></div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;  <span class="comment">// two consecutive wraparounds, so the lack of bits to respresent time is</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  <span class="comment">// neither a performance nor correctness concern</span></div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;  <span class="keyword">auto</span> data = strip(now) | waitMode;</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="keyword">auto</span> signal = (shouldPublish || !spins || (waitMode != kCombineWaiting))</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;      ? waiter.futex_.exchange(data, std::memory_order_acq_rel)</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;      : waiter.futex_.load(std::memory_order_acquire);</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <span class="keywordflow">return</span> signal &amp; std::numeric_limits&lt;std::uint8_t&gt;::max();</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;}</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160; </div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="keywordtype">bool</span> spin(Waiter&amp; waiter, std::uint32_t&amp; sig, std::uint32_t mode) {</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;  <span class="keyword">auto</span> spins = std::uint64_t{0};</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  <span class="keyword">auto</span> waitMode = (mode == kCombineUninitialized) ? kCombineWaiting : kWaiting;</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;  <span class="keyword">auto</span> previous = time();</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  <span class="keyword">auto</span> shouldPublish = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;    <span class="keyword">auto</span> signal = publish(spins++, shouldPublish, previous, waiter, waitMode);</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160; </div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;    <span class="comment">// if we got skipped, make a note of it and return if we got a skipped</span></div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    <span class="comment">// signal or a signal to wake up</span></div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;    <span class="keyword">auto</span> skipped = (signal == kSkipped);</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    <span class="keyword">auto</span> combined = (signal == kCombined);</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="keyword">auto</span> exceptionOccurred = (signal == kExceptionOccurred);</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    <span class="keyword">auto</span> woken = (signal == kWake);</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="keywordflow">if</span> (skipped || woken || combined || exceptionOccurred) {</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;      sig = <span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(signal);</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;      <span class="keywordflow">return</span> !skipped;</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    }</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160; </div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    <span class="comment">// if we are under the spin threshold, pause to allow the other</span></div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;    <span class="comment">// hyperthread to run.  If not, then sleep</span></div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;    <span class="keywordflow">if</span> (spins &lt; kMaxSpins) {</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;      asm_volatile_pause();</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;      Sleeper::sleep();</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;    }</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;  }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;}</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160; </div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="keywordtype">void</span> doFutexWake(Waiter* waiter) {</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;  <span class="keywordflow">if</span> (waiter) {</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;    <span class="comment">// We can use a simple store operation here and not worry about checking</span></div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;    <span class="comment">// to see if the thread had actually started waiting on the futex, that is</span></div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    <span class="comment">// already done in tryWake() when a sleeping thread is collected</span></div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    <span class="comment">// We now do not know whether the waiter had already enqueued on the futex</span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    <span class="comment">// or whether it had just stored kSleeping in its futex and was about to</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="comment">// call futexWait().  We treat both these scenarios the same</span></div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="comment">// the below can theoretically cause a problem if we set the</span></div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    <span class="comment">// wake signal and the waiter was in between setting kSleeping in its</span></div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <span class="comment">// futex and enqueueing on the futex.  In this case the waiter will just</span></div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="comment">// return from futexWait() immediately.  This leaves the address that the</span></div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    <span class="comment">// waiter was using for futexWait() possibly dangling, and the thread that</span></div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="comment">// we woke in the exchange above might have used that address for some</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;    <span class="comment">// other object</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <span class="comment">// however, even if the thread had indeed woken up simply becasue of the</span></div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;    <span class="comment">// above exchange(), the futexWake() below is not incorrect.  It is not</span></div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;    <span class="comment">// incorrect because futexWake() does not actually change the memory of</span></div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;    <span class="comment">// the futex word.  It just uses the address to do a lookup in the kernel</span></div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;    <span class="comment">// futex table.  And even if we call futexWake() on some other address,</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;    <span class="comment">// and that address was being used to wait on futex() that thread will</span></div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;    <span class="comment">// protect itself from spurious wakeups, check the value in the futex word</span></div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;    <span class="comment">// and enqueue itself back on the futex</span></div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;    <span class="comment">// this dangilng pointer possibility is why we use a pointer to the futex</span></div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;    <span class="comment">// word, and avoid dereferencing after the store() operation</span></div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;    <span class="keyword">auto</span> sleeper = &amp;waiter-&gt;metadata_.sleeper_;</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;    sleeper-&gt;store(kWake, std::memory_order_release);</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;    futexWake(sleeper, 1);</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;  }</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;}</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160; </div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="keywordtype">bool</span> doFutexWait(Waiter* waiter, Waiter*&amp; next) {</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;  <span class="comment">// first we get ready to sleep by calling exchange() on the futex with a</span></div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;  <span class="comment">// kSleeping value</span></div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;  assert(waiter-&gt;futex_.load(std::memory_order_relaxed) == kAboutToWait);</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160; </div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;  <span class="comment">// note the semantics of using a futex here, when we exchange the sleeper_</span></div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;  <span class="comment">// with kSleeping, we are getting ready to sleep, but before sleeping we get</span></div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;  <span class="comment">// ready to sleep, and we return from futexWait() when the value of</span></div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  <span class="comment">// sleeper_ might have changed.  We can also wake up because of a spurious</span></div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;  <span class="comment">// wakeup, so we always check against the value in sleeper_ after returning</span></div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;  <span class="comment">// from futexWait(), if the value is not kWake, then we continue</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;  <span class="keyword">auto</span> pre =</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;      waiter-&gt;metadata_.sleeper_.exchange(kSleeping, std::memory_order_acq_rel);</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160; </div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;  <span class="comment">// Seeing a kSleeping on a futex word before we set it ourselves means only</span></div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;  <span class="comment">// one thing - an unlocking thread caught us before we went to futex(), and</span></div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;  <span class="comment">// we now have the lock, so we abort</span></div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;  <span class="comment">// if we were given an early delivery, we can return from this function with</span></div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;  <span class="comment">// a true, meaning that we now have the lock</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;  <span class="keywordflow">if</span> (pre == kSleeping) {</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;  }</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160; </div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;  <span class="comment">// if we reach here then were were not given an early delivery, and any</span></div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;  <span class="comment">// thread that goes to wake us up will see a consistent view of the rest of</span></div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;  <span class="comment">// the contention chain (since the next_ variable is set before the</span></div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;  <span class="comment">// kSleeping exchange above)</span></div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  <span class="keywordflow">while</span> (pre != kWake) {</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;    <span class="comment">// before enqueueing on the futex, we wake any waiters that we were</span></div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="comment">// possibly responsible for</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    doFutexWake(folly::exchange(next, <span class="keyword">nullptr</span>));</div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160; </div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <span class="comment">// then we wait on the futex</span></div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <span class="comment">// note that we have to protect ourselves against spurious wakeups here.</span></div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;    <span class="comment">// Because the corresponding futexWake() above does not synchronize</span></div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;    <span class="comment">// wakeups around the futex word.  Because doing so would become</span></div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    <span class="comment">// inefficient</span></div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    futexWait(&amp;waiter-&gt;metadata_.sleeper_, kSleeping);</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    pre = waiter-&gt;metadata_.sleeper_.load(std::memory_order_acquire);</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    assert((pre == kSleeping) || (pre == kWake));</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;  }</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160; </div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  <span class="comment">// when coming out of a futex, we might have some other sleeping threads</span></div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;  <span class="comment">// that we were supposed to wake up, assign that to the next pointer</span></div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  assert(next == <span class="keyword">nullptr</span>);</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;  next = extractPtr&lt;Waiter&gt;(waiter-&gt;next_.load(std::memory_order_relaxed));</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;}</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160; </div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="keywordtype">bool</span> wait(Waiter* waiter, std::uint32_t mode, Waiter*&amp; next, uint32_t&amp; signal) {</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;  <span class="keywordflow">if</span> (mode == kAboutToWait) {</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keywordflow">return</span> doFutexWait(waiter, next);</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;  }</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160; </div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;  <span class="keywordflow">return</span> spin(*waiter, signal, mode);</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;}</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160; </div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> recordTimedWaiterAndClearTimedBit(</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    <span class="keywordtype">bool</span>&amp; timedWaiter,</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;    std::uintptr_t&amp; previous) {</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;  <span class="comment">// the previous value in the mutex can never be kTimedWaiter, timed waiters</span></div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;  <span class="comment">// always set (kTimedWaiter | kLocked) in the mutex word when they try and</span></div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;  <span class="comment">// acquire the mutex</span></div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;  assert(previous != kTimedWaiter);</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160; </div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;  <span class="keywordflow">if</span> ((previous &amp; kTimedWaiter)) {</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;    <span class="comment">// record whether there was a timed waiter in the previous mutex state, and</span></div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;    <span class="comment">// clear the timed bit from the previous state</span></div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    timedWaiter = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;    previous = previous &amp; (~kTimedWaiter);</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;  }</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;}</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160; </div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Atomic&gt;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="keywordtype">void</span> wakeTimedWaiters(Atomic* state, <span class="keywordtype">bool</span> timedWaiters) {</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="keywordflow">if</span> ((timedWaiters)) {</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    atomic_notify_one(state);</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;  }</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;}</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160; </div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="keyword">auto</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a9870e8ffbfa7851f4512c24ccb8c57eb">DistributedMutex&lt;Atomic, TimePublishing&gt;::lock_combine</a>(Func func)</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    -&gt; decltype(std::declval&lt;const Func&amp;&gt;()()) {</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;  <span class="comment">// invoke the lock implementation function and check whether we came out of</span></div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;  <span class="comment">// it with our task executed as a combined critical section.  This usually</span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;  <span class="comment">// happens when the mutex is contended.</span></div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;  <span class="comment">// In the absence of contention, we just return from the try_lock() function</span></div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;  <span class="comment">// with the lock acquired.  So we need to invoke the task and unlock</span></div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;  <span class="comment">// the mutex before returning</span></div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;  <span class="keyword">auto</span>&amp;&amp; task = Request&lt;Func&gt;{func};</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;  <span class="keyword">auto</span>&amp;&amp; state = lockImplementation(*<span class="keyword">this</span>, state_, task);</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;  <span class="keywordflow">if</span> (!state.combined_) {</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;    <span class="comment">// to avoid having to play a return-value dance when the combinable</span></div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;    <span class="comment">// returns void, we use a scope exit to perform the unlock after the</span></div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;    <span class="comment">// function return has been processed</span></div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;    SCOPE_EXIT {</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;      unlock(std::move(state));</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    };</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    <span class="keywordflow">return</span> func();</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;  }</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160; </div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;  <span class="comment">// if we are here, that means we were able to get our request combined, we</span></div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  <span class="comment">// can return the value that was transferred to us</span></div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;  <span class="comment">// each thread that enqueues as a part of a contention chain takes up the</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;  <span class="comment">// responsibility of any timed waiter that had come immediately before it,</span></div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;  <span class="comment">// so we wake up timed waiters before exiting the lock function.  Another</span></div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;  <span class="comment">// strategy might be to add the timed waiter information to the metadata and</span></div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;  <span class="comment">// let a single leader wake up a timed waiter for better concurrency.  But</span></div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;  <span class="comment">// this has proven not to be useful in benchmarks beyond a small 5% delta,</span></div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <span class="comment">// so we avoid taking the complexity hit and branch to wake up timed waiters</span></div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;  <span class="comment">// from each thread</span></div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;  wakeTimedWaiters(&amp;state_, state.timedWaiters_);</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;  <span class="keywordflow">return</span> std::move(task).get();</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;}</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160; </div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="keyword">typename</span> DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutexStateProxy</div>
<div class="line"><a name="l01090"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a85c5d1b40693aa78f4d57f97a9cdea25"> 1090</a></span>&#160;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a85c5d1b40693aa78f4d57f97a9cdea25">DistributedMutex&lt;Atomic, TimePublishing&gt;::lock</a>() {</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;  <span class="keyword">auto</span> <span class="keyword">null</span> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;  <span class="keywordflow">return</span> lockImplementation(*<span class="keyword">this</span>, state_, <span class="keyword">null</span>);</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;}</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160; </div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Atomic, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>A, <span class="keywordtype">bool</span> T&gt;</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="keyword">auto</span> tryLockNoLoad(Atomic&amp; atomic, <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex&lt;A, T&gt;</a>&amp;)</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    -&gt; <span class="keyword">typename</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutex&lt;A, T&gt;::DistributedMutexStateProxy</a> {</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;  <span class="comment">// Try and set the least significant bit of the centralized lock state to 1,</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;  <span class="comment">// if this succeeds, it must have been the case that we had a kUnlocked (or</span></div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;  <span class="comment">// 0) in the central storage before, since that is the only case where a 0</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;  <span class="comment">// can be found in the least significant bit</span></div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;  <span class="comment">// If this fails, then it is a no-op</span></div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;  <span class="keyword">using</span> Proxy = <span class="keyword">typename</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutex&lt;A, T&gt;::DistributedMutexStateProxy</a>;</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;  <span class="keyword">auto</span> previous = atomic_fetch_set(atomic, 0, std::memory_order_acquire);</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;  <span class="keywordflow">if</span> (!previous) {</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;    <span class="keywordflow">return</span> Proxy{<span class="keyword">nullptr</span>, kLocked};</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;  }</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160; </div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;  <span class="keywordflow">return</span> Proxy{<span class="keyword">nullptr</span>, 0};</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;}</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160; </div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="keyword">typename</span> DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutexStateProxy</div>
<div class="line"><a name="l01115"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed"> 1115</a></span>&#160;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">DistributedMutex&lt;Atomic, TimePublishing&gt;::try_lock</a>() {</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  <span class="comment">// The lock attempt below requires an expensive atomic fetch-and-mutate or</span></div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  <span class="comment">// an even more expensive atomic compare-and-swap loop depending on the</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  <span class="comment">// platform.  These operations require pulling the lock cacheline into the</span></div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  <span class="comment">// current core in exclusive mode and are therefore hard to parallelize</span></div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  <span class="comment">// This probabilistically avoids the expense by first checking whether the</span></div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;  <span class="comment">// mutex is currently locked</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;  <span class="keywordflow">if</span> (state_.load(std::memory_order_relaxed) != kUnlocked) {</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>{<span class="keyword">nullptr</span>, 0};</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;  }</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160; </div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;  <span class="keywordflow">return</span> tryLockNoLoad(state_, *<span class="keyword">this</span>);</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;}</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160; </div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="keyword">template</span> &lt;</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic,</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    <span class="keywordtype">bool</span> TimePublishing,</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    <span class="keyword">typename</span> State,</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    <span class="keyword">typename</span> Request&gt;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="keyword">typename</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutexStateProxy</a></div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;lockImplementation(</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">DistributedMutex&lt;Atomic, TimePublishing&gt;</a>&amp; mutex,</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    State&amp; atomic,</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    Request&amp; request) {</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;  <span class="comment">// first try and acquire the lock as a fast path, the underlying</span></div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;  <span class="comment">// implementation is slightly faster than using std::atomic::exchange() as</span></div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;  <span class="comment">// is used in this function.  So we get a small perf boost in the</span></div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;  <span class="comment">// uncontended case</span></div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  <span class="comment">// We only go through this fast path for the lock/unlock usage and avoid this</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;  <span class="comment">// for combined critical sections.  This check adds unnecessary overhead in</span></div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;  <span class="comment">// that case as it causes an extra cacheline bounce</span></div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;  constexpr <span class="keyword">auto</span> combineRequested = !std::is_same&lt;Request, std::nullptr_t&gt;{};</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;  <span class="keywordflow">if</span> (!combineRequested) {</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">auto</span> state = tryLockNoLoad(atomic, mutex)) {</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;      <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;    }</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;  }</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160; </div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;  <span class="keyword">auto</span> previous = std::uintptr_t{0};</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;  <span class="keyword">auto</span> waitMode = combineRequested ? kCombineUninitialized : kUninitialized;</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;  <span class="keyword">auto</span> nextWaitMode = kAboutToWait;</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  <span class="keyword">auto</span> timedWaiter = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;  Waiter&lt;Atomic&gt;* nextSleeper = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    <span class="comment">// construct the state needed to wait</span></div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;    <span class="comment">// We can&#39;t use auto here because MSVC errors out due to a missing copy</span></div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    <span class="comment">// constructor</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    Waiter&lt;Atomic&gt; state{};</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    <span class="keyword">auto</span>&amp;&amp; task = coalesce(request, state);</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    <span class="keyword">auto</span>&amp;&amp; storage = makeReturnValueStorageFor(task);</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    <span class="keyword">auto</span>&amp;&amp; address = folly::bit_cast&lt;std::uintptr_t&gt;(&amp;state);</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    attach(task, storage);</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;    state.initialize(waitMode, std::move(task));</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    assert(!(address &amp; 0b1));</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160; </div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;    <span class="comment">// set the locked bit in the address we will be persisting in the mutex</span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    address |= kLocked;</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160; </div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <span class="comment">// attempt to acquire the mutex, mutex acquisition is successful if the</span></div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    <span class="comment">// previous value is zeroed out</span></div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <span class="comment">// we use memory_order_acq_rel here because we want the read-modify-write</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    <span class="comment">// operation to be both acquire and release.  Acquire becasue if this is a</span></div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    <span class="comment">// successful lock acquisition, we want to acquire state any other thread</span></div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    <span class="comment">// has released from a prior unlock.  We want release semantics becasue</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    <span class="comment">// other threads that read the address of this value should see the full</span></div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    <span class="comment">// well-initialized node we are going to wait on if the mutex acquisition</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    <span class="comment">// was unsuccessful</span></div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;    previous = atomic.exchange(address, std::memory_order_acq_rel);</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    recordTimedWaiterAndClearTimedBit(timedWaiter, previous);</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    state.next_.store(previous, std::memory_order_relaxed);</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    <span class="keywordflow">if</span> (previous == kUnlocked) {</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;      <span class="keywordflow">return</span> {<span class="comment">/* next */</span> <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;              <span class="comment">/* expected */</span> address,</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;              <span class="comment">/* timedWaiter */</span> timedWaiter,</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;              <span class="comment">/* combined */</span> <span class="keyword">false</span>,</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;              <span class="comment">/* waker */</span> 0,</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;              <span class="comment">/* waiters */</span> <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;              <span class="comment">/* ready */</span> nextSleeper};</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;    }</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    assert(previous &amp; kLocked);</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160; </div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;    <span class="comment">// wait until we get a signal from another thread, if this returns false,</span></div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    <span class="comment">// we got skipped and had probably been scheduled out, so try again</span></div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    <span class="keyword">auto</span> signal = kUninitialized;</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    <span class="keywordflow">if</span> (!wait(&amp;state, waitMode, nextSleeper, signal)) {</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;      std::swap(waitMode, nextWaitMode);</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;      <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;    }</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160; </div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    <span class="comment">// at this point it is safe to access the other fields in the waiter state,</span></div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;    <span class="comment">// since the thread that woke us up is gone and nobody will be touching this</span></div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    <span class="comment">// state again, note that this requires memory ordering, and this is why we</span></div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    <span class="comment">// use memory_order_acquire (among other reasons) in the above wait</span></div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;    <span class="comment">// first we see if the value we took off the mutex state was the thread that</span></div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;    <span class="comment">// initated the wakeups, if so, we are the terminal node of the current</span></div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;    <span class="comment">// contention chain.  If we are the terminal node, then we should expect to</span></div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;    <span class="comment">// see a kLocked in the mutex state when we unlock, if we see that, we can</span></div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;    <span class="comment">// commit the unlock to the centralized mutex state.  If not, we need to</span></div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;    <span class="comment">// continue wakeups</span></div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;    <span class="comment">// a nice consequence of passing kLocked as the current address if we are</span></div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;    <span class="comment">// the terminal node is that it naturally just works with the algorithm.  If</span></div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;    <span class="comment">// we get a contention chain when coming out of a contention chain, the tail</span></div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    <span class="comment">// of the new contention chain will have kLocked set as the previous, which,</span></div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;    <span class="comment">// as it happens &quot;just works&quot;, since we have now established a recursive</span></div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;    <span class="comment">// relationship until broken</span></div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;    <span class="keyword">auto</span> next = previous;</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;    <span class="keyword">auto</span> expected = address;</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;    <span class="keywordflow">if</span> (previous == state.metadata_.waker_) {</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;      next = 0;</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;      expected = kLocked;</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    }</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160; </div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    <span class="comment">// if we were given a combine signal, detach the return value from the</span></div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;    <span class="comment">// wait struct into the request, so the current thread can access it</span></div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    <span class="comment">// outside this function</span></div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;    <span class="keyword">auto</span> combined = (signal == kCombined);</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    <span class="keyword">auto</span> exceptionOccurred = (signal == kExceptionOccurred);</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    <span class="keywordflow">if</span> (combined || exceptionOccurred) {</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;      detach(request, state, exceptionOccurred, storage);</div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;    }</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160; </div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    <span class="comment">// if we are just coming out of a futex call, then it means that the next</span></div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;    <span class="comment">// waiter we are responsible for is also a waiter waiting on a futex, so</span></div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;    <span class="comment">// we return that list in the list of ready threads.  We wlil be waking up</span></div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="comment">// the ready threads on unlock no matter what</span></div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;    <span class="keywordflow">return</span> {<span class="comment">/* next */</span> extractPtr&lt;Waiter&lt;Atomic&gt;&gt;(next),</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;            <span class="comment">/* expected */</span> expected,</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;            <span class="comment">/* timedWaiter */</span> timedWaiter,</div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;            <span class="comment">/* combined */</span> combineRequested &amp;&amp; (combined || exceptionOccurred),</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;            <span class="comment">/* waker */</span> state.metadata_.waker_,</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;            <span class="comment">/* waiters */</span> extractPtr&lt;Waiter&lt;Atomic&gt;&gt;(state.metadata_.waiters_),</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;            <span class="comment">/* ready */</span> nextSleeper};</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;  }</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;}</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160; </div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> preempted(std::uint64_t value, std::chrono::nanoseconds now) {</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;  <span class="keyword">auto</span> currentTime = recover(strip(now));</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;  <span class="keyword">auto</span> nodeTime = recover(value);</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;  <span class="keyword">auto</span> preempted =</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;      (currentTime &gt; nodeTime + kScheduledAwaySpinThreshold.count()) &amp;&amp;</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;      (nodeTime != recover(strip(std::chrono::nanoseconds::max())));</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160; </div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;  <span class="comment">// we say that the thread has been preempted if its timestamp says so, and</span></div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  <span class="comment">// also if it is neither uninitialized nor skipped</span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;  assert(value != kSkipped);</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  <span class="keywordflow">return</span> (preempted) &amp;&amp; (value != kUninitialized) &amp;&amp;</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;      (value != kCombineUninitialized);</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;}</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160; </div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> isSleeper(std::uintptr_t value) {</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;  <span class="keywordflow">return</span> (value == kAboutToWait);</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;}</div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160; </div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> isInitialized(std::uintptr_t value) {</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;  <span class="keywordflow">return</span> (value != kUninitialized) &amp;&amp; (value != kCombineUninitialized);</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;}</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160; </div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> isCombiner(std::uintptr_t value) {</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;  <span class="keyword">auto</span> mode = (value &amp; 0xff);</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;  <span class="keywordflow">return</span> (mode == kCombineWaiting) || (mode == kCombineUninitialized);</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;}</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160; </div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> isWaitingCombiner(std::uintptr_t value) {</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;  <span class="keywordflow">return</span> (value &amp; 0xff) == kCombineWaiting;</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;}</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160; </div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;CombineFunction loadTask(Waiter* current, std::uintptr_t value) {</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;  <span class="comment">// if we know that the waiter is a combiner of some sort, it is safe to read</span></div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;  <span class="comment">// and copy the value of the function in the waiter struct, since we know</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;  <span class="comment">// that a waiter would have set it before enqueueing</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;  <span class="keywordflow">if</span> (isCombiner(value)) {</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    <span class="keywordflow">return</span> current-&gt;function_;</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;  }</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160; </div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;}</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160; </div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="keywordtype">void</span> transferCurrentException(Waiter* waiter) {</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;  assert(std::current_exception());</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;  <span class="keyword">new</span> (&amp;waiter-&gt;storage_) std::exception_ptr(std::current_exception());</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;  waiter-&gt;futex_.store(kExceptionOccurred, std::memory_order_release);</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;}</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160; </div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic&gt;</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="keyword">inline</span> std::uintptr_t tryCombine(</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;    Waiter&lt;Atomic&gt;* waiter,</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;    std::uintptr_t value,</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;    std::uintptr_t next,</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;    std::uint64_t iteration,</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    std::chrono::nanoseconds now,</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    CombineFunction task) {</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="preprocessor">#ifndef ROCKSDB_LITE</span></div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;  <span class="comment">// if the waiter has asked for a combine operation, we should combine its</span></div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;  <span class="comment">// critical section and move on to the next waiter</span></div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;  <span class="comment">// the waiter is combinable if the following conditions are satisfied</span></div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;  <span class="comment">//  1) the state in the futex word is not uninitialized (kUninitialized)</span></div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;  <span class="comment">//  2) it has a valid combine function</span></div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;  <span class="comment">//  3) we are not past the limit of the number of combines we can perform</span></div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;  <span class="comment">//     or the waiter thread been preempted.  If the waiter gets preempted,</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;  <span class="comment">//     its better to just execute their critical section before moving on.</span></div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;  <span class="comment">//     As they will have to re-queue themselves after preemption anyway,</span></div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;  <span class="comment">//     leading to further delays in critical section completion</span></div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;  <span class="comment">// if all the above are satisfied, then we can combine the critical section.</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;  <span class="comment">// Note that if the waiter is in a combineable state, that means that it had</span></div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;  <span class="comment">// finished its writes to both the task and the next_ value.  And observing</span></div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;  <span class="comment">// a waiting state also means that we have acquired the writes to the other</span></div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;  <span class="comment">// members of the waiter struct, so it&#39;s fine to use those values here</span></div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;  <span class="keywordflow">if</span> (isWaitingCombiner(value) &amp;&amp;</div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;      (iteration &lt;= kMaxCombineIterations || preempted(value, now))) {</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;    <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;      task();</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;      waiter-&gt;futex_.store(kCombined, std::memory_order_release);</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;      transferCurrentException(waiter);</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;    }</div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;    <span class="keywordflow">return</span> next;</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;  }</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="preprocessor">#endif  // ROCKSDB_LITE</span></div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;  <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;}</div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160; </div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="keyword">inline</span> std::uintptr_t tryWake(</div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;    <span class="keywordtype">bool</span> publishing,</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    Waiter* waiter,</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    std::uintptr_t value,</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    std::uintptr_t next,</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;    std::uintptr_t waker,</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;    Waiter*&amp; sleepers,</div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;    std::uint64_t iteration,</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;    CombineFunction task) {</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;  <span class="comment">// try and combine the waiter&#39;s request first, if that succeeds that means</span></div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;  <span class="comment">// we have successfully executed their critical section and can move on to</span></div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;  <span class="comment">// the rest of the chain</span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;  <span class="keyword">auto</span> now = time();</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;  <span class="keywordflow">if</span> (tryCombine(waiter, value, next, iteration, now, task)) {</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;    <span class="keywordflow">return</span> next;</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;  }</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160; </div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  <span class="comment">// first we see if we can wake the current thread that is spinning</span></div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;  <span class="keywordflow">if</span> ((!publishing || !preempted(value, now)) &amp;&amp; !isSleeper(value)) {</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;    <span class="comment">// the Metadata class should be trivially destructible as we use placement</span></div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;    <span class="comment">// new to set the relevant metadata without calling any destructor.  We</span></div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;    <span class="comment">// need to use placement new because the class contains a futex, which is</span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;    <span class="comment">// non-movable and non-copyable</span></div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    <span class="keyword">using</span> <a class="code" href="classMetadata.html">Metadata</a> = _t&lt;std::decay&lt;decltype(waiter-&gt;metadata_)&gt;&gt;;</div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;    static_assert(std::is_trivially_destructible&lt;Metadata&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160; </div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;    <span class="comment">// we need release here because of the write to waker_ and also because we</span></div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    <span class="comment">// are unlocking the mutex, the thread we do the handoff to here should</span></div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;    <span class="comment">// see the modified data</span></div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;    <span class="keyword">new</span> (&amp;waiter-&gt;metadata_)</div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;        <a class="code" href="classMetadata.html">Metadata</a>(waker, folly::bit_cast&lt;std::uintptr_t&gt;(sleepers));</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    waiter-&gt;futex_.store(kWake, std::memory_order_release);</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;  }</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160; </div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;  <span class="comment">// if the thread is not a sleeper, and we were not able to catch it before</span></div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;  <span class="comment">// preemption, we can just return a false, it is safe to read next_ because</span></div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;  <span class="comment">// the thread was preempted.  Preemption signals can only come after the</span></div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;  <span class="comment">// thread has set the next_ pointer, since the timestamp writes only start</span></div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;  <span class="comment">// occurring after that point</span></div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;  <span class="comment">// if a thread was preempted it must have stored next_ in the waiter struct,</span></div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;  <span class="comment">// as the store to futex_ that resets the value from kUninitialized happens</span></div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;  <span class="comment">// after the write to next</span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;  assert(publishing);</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;  <span class="keywordflow">if</span> (!isSleeper(value)) {</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;    <span class="comment">// go on to the next one</span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;    <span class="comment">// Also, we need a memory_order_release here to prevent missed wakeups.  A</span></div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;    <span class="comment">// missed wakeup here can happen when we see that a thread had been</span></div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;    <span class="comment">// preempted and skip it.  Then go on to release the lock, and then when</span></div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;    <span class="comment">// the thread which got skipped does an exchange on the central storage,</span></div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    <span class="comment">// still sees the locked bit, and never gets woken up</span></div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;    <span class="comment">// Can we relax this?</span></div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;    assert(preempted(value, now));</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;    assert(!isCombiner(value));</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    next = waiter-&gt;next_.load(std::memory_order_relaxed);</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;    waiter-&gt;futex_.store(kSkipped, std::memory_order_release);</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    <span class="keywordflow">return</span> next;</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;  }</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160; </div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;  <span class="comment">// if we are here the thread is a sleeper</span></div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;  <span class="comment">// we attempt to catch the thread before it goes to futex().  If we are able</span></div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;  <span class="comment">// to catch the thread before it sleeps on a futex, we are done, and don&#39;t</span></div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;  <span class="comment">// need to go any further</span></div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;  <span class="comment">// if we are not able to catch the thread before it goes to futex, we</span></div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;  <span class="comment">// collect the current thread in the list of sleeping threads represented by</span></div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;  <span class="comment">// sleepers, and return the next thread in the list and return false along</span></div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;  <span class="comment">// with the previous next value</span></div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;  <span class="comment">// it is safe to read the next_ pointer in the waiter struct if we were</span></div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;  <span class="comment">// unable to catch the thread before it went to futex() because we use</span></div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;  <span class="comment">// acquire-release ordering for the exchange operation below.  And if we see</span></div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;  <span class="comment">// that the thread was already sleeping, we have synchronized with the write</span></div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;  <span class="comment">// to next_ in the context of the sleeping thread</span></div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;  <span class="comment">// Also we need to set the value of waiters_ and waker_ in the thread before</span></div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;  <span class="comment">// doing the exchange because we need to pass on the list of sleepers in the</span></div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;  <span class="comment">// event that we were able to catch the thread before it went to futex().</span></div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;  <span class="comment">// If we were unable to catch the thread before it slept, these fields will</span></div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;  <span class="comment">// be ignored when the thread wakes up anyway</span></div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;  assert(isSleeper(value));</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;  waiter-&gt;metadata_.waker_ = waker;</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;  waiter-&gt;metadata_.waiters_ = folly::bit_cast&lt;std::uintptr_t&gt;(sleepers);</div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;  <span class="keyword">auto</span> pre =</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;      waiter-&gt;metadata_.sleeper_.exchange(kSleeping, std::memory_order_acq_rel);</div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160; </div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;  <span class="comment">// we were able to catch the thread before it went to sleep, return true</span></div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;  <span class="keywordflow">if</span> (pre != kSleeping) {</div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;  }</div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160; </div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;  <span class="comment">// otherwise return false, with the value of next_, it is safe to read next</span></div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;  <span class="comment">// because of the same logic as when a thread was preempted</span></div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;  <span class="comment">// we also need to collect this sleeper in the list of sleepers being built</span></div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;  <span class="comment">// up</span></div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;  next = waiter-&gt;next_.load(std::memory_order_relaxed);</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;  <span class="keyword">auto</span> head = folly::bit_cast&lt;std::uintptr_t&gt;(sleepers);</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;  waiter-&gt;next_.store(head, std::memory_order_relaxed);</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;  sleepers = waiter;</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;  <span class="keywordflow">return</span> next;</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;}</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160; </div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Waiter&gt;</div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="keywordtype">bool</span> wake(</div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;    <span class="keywordtype">bool</span> publishing,</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;    Waiter&amp; waiter,</div>
<div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    std::uintptr_t waker,</div>
<div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    Waiter*&amp; sleepers,</div>
<div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;    std::uint64_t iter) {</div>
<div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;  <span class="comment">// loop till we find a node that is either at the end of the list (as</span></div>
<div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;  <span class="comment">// specified by waker) or we find a node that is active (as specified by</span></div>
<div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;  <span class="comment">// the last published timestamp of the node)</span></div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;  <span class="keyword">auto</span> current = &amp;waiter;</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;  <span class="keywordflow">while</span> (current) {</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;    <span class="comment">// it is important that we load the value of function and next_ after the</span></div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;    <span class="comment">// initial acquire load.  This is required because we need to synchronize</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    <span class="comment">// with the construction of the waiter struct before reading from it</span></div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;    <span class="comment">// the load from the next_ variable is an optimistic load that assumes</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;    <span class="comment">// that the waiting thread has probably gone to the waiting state.  If the</span></div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    <span class="comment">// waiitng thread is in the waiting state (as revealed by the acquire load</span></div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;    <span class="comment">// from the futex word), we will see a well formed next_ value because it</span></div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    <span class="comment">// happens-before the release store to the futex word.  The atomic load from</span></div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;    <span class="comment">// next_ is an optimization to avoid branching before loading and prevent</span></div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;    <span class="comment">// the compiler from eliding the load altogether (and using a pointer</span></div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;    <span class="comment">// dereference when needed)</span></div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;    <span class="keyword">auto</span> value = current-&gt;futex_.load(std::memory_order_acquire);</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    <span class="keyword">auto</span> next = current-&gt;next_.load(std::memory_order_relaxed);</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;    <span class="keyword">auto</span> task = loadTask(current, value);</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;    next =</div>
<div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;        tryWake(publishing, current, value, next, waker, sleepers, iter, task);</div>
<div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160; </div>
<div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;    <span class="comment">// if there is no next node, we have managed to wake someone up and have</span></div>
<div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;    <span class="comment">// successfully migrated the lock to another thread</span></div>
<div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;    <span class="keywordflow">if</span> (!next) {</div>
<div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;    }</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160; </div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;    <span class="comment">// we need to read the value of the next node in the list before skipping</span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    <span class="comment">// it, this is because after we skip it the node might wake up and enqueue</span></div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;    <span class="comment">// itself, and thereby gain a new next node</span></div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    assert(publishing);</div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;    current = (next == waker) ? <span class="keyword">nullptr</span> : extractPtr&lt;Waiter&gt;(next);</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;  }</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160; </div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;}</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160; </div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Atomic, <span class="keyword">typename</span> Proxy, <span class="keyword">typename</span> Sleepers&gt;</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="keywordtype">bool</span> tryUnlockClean(Atomic&amp; state, Proxy&amp; proxy, Sleepers sleepers) {</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;  <span class="keyword">auto</span> expected = proxy.expected_;</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;    <span class="keywordflow">if</span> (state.compare_exchange_strong(</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;            expected,</div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;            kUnlocked,</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;            std::memory_order_release,</div>
<div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;            std::memory_order_relaxed)) {</div>
<div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;      <span class="comment">// if we were able to commit an unlocked, we need to wake up the futex</span></div>
<div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;      <span class="comment">// waiters, if any</span></div>
<div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;      doFutexWake(sleepers);</div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;    }</div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160; </div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;    <span class="comment">// if we failed the compare_exchange_strong() above, we check to see if</span></div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;    <span class="comment">// the failure was because of the presence of a timed waiter.  If that</span></div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    <span class="comment">// was the case then we try one more time with the kTimedWaiter bit set</span></div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    <span class="keywordflow">if</span> (expected == (proxy.expected_ | kTimedWaiter)) {</div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;      proxy.timedWaiters_ = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;      <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    }</div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160; </div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;    <span class="comment">// otherwise break, we have a contention chain</span></div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;  }</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;}</div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160; </div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> Publish&gt;</div>
<div class="line"><a name="l01530"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87"> 1530</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87">DistributedMutex&lt;Atomic, Publish&gt;::unlock</a>(</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    <span class="keyword">typename</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutex::DistributedMutexStateProxy</a> proxy) {</div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;  <span class="comment">// we always wake up ready threads and timed waiters if we saw either</span></div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;  assert(proxy);</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;  assert(!proxy.combined_);</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;  SCOPE_EXIT {</div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;    doFutexWake(proxy.ready_);</div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;    wakeTimedWaiters(&amp;state_, proxy.timedWaiters_);</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;  };</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160; </div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;  <span class="comment">// if there is a wait queue we are responsible for, try and start wakeups,</span></div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;  <span class="comment">// don&#39;t bother with the mutex state</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;  <span class="keyword">auto</span> sleepers = proxy.waiters_;</div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;  <span class="keywordflow">if</span> (proxy.next_) {</div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;    <span class="keywordflow">if</span> (wake(Publish, *proxy.next_, proxy.waker_, sleepers, 0)) {</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;    }</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160; </div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;    <span class="comment">// At this point, if are in the if statement, we were not the terminal</span></div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;    <span class="comment">// node of the wakeup chain.  Terminal nodes have the next_ pointer set to</span></div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;    <span class="comment">// null in lock()</span></div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;    <span class="comment">// So we need to pretend we were the end of the contention chain.  Coming</span></div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;    <span class="comment">// out of a contention chain always has the kLocked state set in the</span></div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;    <span class="comment">// mutex.  Unless there is another contention chain lined up, which does</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;    <span class="comment">// not matter since we are the terminal node anyway</span></div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;    proxy.expected_ = kLocked;</div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;  }</div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160; </div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;  <span class="keywordflow">for</span> (std::uint64_t i = 0; <span class="keyword">true</span>; ++i) {</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;    <span class="comment">// otherwise, since we don&#39;t have anyone we need to wake up, we try and</span></div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;    <span class="comment">// release the mutex just as is</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;    <span class="comment">// if this is successful, we can return, the unlock was successful, we have</span></div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;    <span class="comment">// committed a nice kUnlocked to the central storage, yay</span></div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;    <span class="keywordflow">if</span> (tryUnlockClean(state_, proxy, sleepers)) {</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;    }</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160; </div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;    <span class="comment">// here we have a contention chain built up on the mutex.  We grab the</span></div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;    <span class="comment">// wait queue and start executing wakeups.  We leave a locked bit on the</span></div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;    <span class="comment">// centralized storage and handoff control to the head of the queue</span></div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;    <span class="comment">// we use memory_order_acq_rel here because we want to see the</span></div>
<div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    <span class="comment">// full well-initialized node that the other thread is waiting on</span></div>
<div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    <span class="comment">// If we are unable to wake the contention chain, it is possible that when</span></div>
<div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;    <span class="comment">// we come back to looping here, a new contention chain will form.  In</span></div>
<div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;    <span class="comment">// that case we need to use kLocked as the waker_ value because the</span></div>
<div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;    <span class="comment">// terminal node of the new chain will see kLocked in the central storage</span></div>
<div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;    <span class="keyword">auto</span> head = state_.exchange(kLocked, std::memory_order_acq_rel);</div>
<div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;    recordTimedWaiterAndClearTimedBit(proxy.timedWaiters_, head);</div>
<div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;    <span class="keyword">auto</span> next = extractPtr&lt;Waiter&lt;Atomic&gt;&gt;(head);</div>
<div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;    <span class="keyword">auto</span> expected = folly::exchange(proxy.expected_, kLocked);</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    assert((head &amp; kLocked) &amp;&amp; (head != kLocked));</div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;    <span class="keywordflow">if</span> (wake(Publish, *next, expected, sleepers, i)) {</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;    }</div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;  }</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;}</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160; </div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Atomic, <span class="keyword">typename</span> Deadline, <span class="keyword">typename</span> MakeProxy&gt;</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="keyword">auto</span> timedLock(Atomic&amp; state, Deadline deadline, MakeProxy proxy)</div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;    -&gt; decltype(std::declval&lt;MakeProxy&amp;&gt;()(<span class="keyword">nullptr</span>, kLocked, <span class="keyword">true</span>)) {</div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    <span class="comment">// we put a bit on the central state to show that there is a timed waiter</span></div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;    <span class="comment">// and go to sleep on the central state</span></div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;    <span class="comment">// when this thread goes to unlock the mutex, it will expect a 0b1 in the</span></div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;    <span class="comment">// mutex state (0b1, not 0b11), but then it will see that the value in the</span></div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    <span class="comment">// mutex state is 0b11 and not 0b1, meaning that there might have been</span></div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;    <span class="comment">// another timed waiter.  Even though there might not have been another</span></div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;    <span class="comment">// timed waiter in the time being.  This sort of missed wakeup is</span></div>
<div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;    <span class="comment">// desirable for timed waiters; it helps avoid thundering herds of timed</span></div>
<div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;    <span class="comment">// waiters.  Because the mutex is packed in 8 bytes, and we need an</span></div>
<div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;    <span class="comment">// address to be stored in those 8 bytes, we don&#39;t have much room to play</span></div>
<div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;    <span class="comment">// with.  The only other solution is to issue a futexWake(INT_MAX) to wake</span></div>
<div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;    <span class="comment">// up all waiters when a clean unlock is committed, when a thread saw a</span></div>
<div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;    <span class="comment">// timed waiter in the mutex previously.</span></div>
<div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;    <span class="comment">// putting a 0b11 here works for a set of reasons that is a superset of</span></div>
<div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;    <span class="comment">// the set of reasons that make it okay to put a kLocked (0b1) in the</span></div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;    <span class="comment">// mutex state.  Now that the thread has put (kTimedWaiter | kLocked)</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;    <span class="comment">// (0b11) in the mutex state and it expects a kLocked (0b1), there are two</span></div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;    <span class="comment">// scenarios possible.  The first being when there is no contention chain</span></div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;    <span class="comment">// formation in the mutex from the time a timed waiter got a lock to</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;    <span class="comment">// unlock.  In this case, the unlocker sees a 0b11 in the mutex state,</span></div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;    <span class="comment">// adjusts to the presence of a timed waiter and cleanly unlocks with a</span></div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;    <span class="comment">// kUnlocked (0b0).  The second is when there is a contention chain.</span></div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;    <span class="comment">// When a thread puts its address in the mutex and sees the timed bit, it</span></div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;    <span class="comment">// records the presence of a timed waiter, and then pretends as if it</span></div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;    <span class="comment">// hadn&#39;t seen the timed bit.  So future contention chain releases, will</span></div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;    <span class="comment">// terminate with a kLocked (0b1) and not a (kLocked | kTimedWaiter)</span></div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;    <span class="comment">// (0b11).  This just works naturally with the rest of the algorithm</span></div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;    <span class="comment">// without incurring a perf hit for the regular non-timed case</span></div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;    <span class="comment">// this strategy does however mean, that when threads try to acquire the</span></div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;    <span class="comment">// mutex and all time out, there will be a wasteful syscall to issue wakeups</span></div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;    <span class="comment">// to waiting threads.  We don&#39;t do anything to try and minimize this</span></div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;    <span class="comment">//</span></div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;    <span class="comment">// we need to use a fetch_or() here because we need to convey two bits of</span></div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;    <span class="comment">// information - 1, whether the mutex is locked or not, and 2, whether</span></div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;    <span class="comment">// there is a timed waiter.  The alternative here is to use the second bit</span></div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;    <span class="comment">// to convey information only, we can use a fetch_set() on the second bit</span></div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;    <span class="comment">// to make this faster, but that comes at the expense of requiring regular</span></div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;    <span class="comment">// fast path lock attempts.  Which use a single bit read-modify-write for</span></div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;    <span class="comment">// better performance</span></div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;    <span class="keyword">auto</span> data = kTimedWaiter | kLocked;</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;    <span class="keyword">auto</span> previous = state.fetch_or(data, std::memory_order_acquire);</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;    <span class="keywordflow">if</span> (!(previous &amp; 0b1)) {</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;      assert(!previous);</div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;      <span class="keywordflow">return</span> proxy(<span class="keyword">nullptr</span>, kLocked, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;    }</div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160; </div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;    <span class="comment">// wait on the futex until signalled, if we get a timeout, the try_lock</span></div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    <span class="comment">// fails</span></div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    <span class="keyword">auto</span> result = atomic_wait_until(&amp;state, previous | data, deadline);</div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;    <span class="keywordflow">if</span> (result == std::cv_status::timeout) {</div>
<div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;      <span class="keywordflow">return</span> proxy(<span class="keyword">nullptr</span>, std::uintptr_t{0}, <span class="keyword">false</span>);</div>
<div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;    }</div>
<div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;  }</div>
<div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;}</div>
<div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160; </div>
<div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</div>
<div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="keyword">typename</span> DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutexStateProxy</div>
<div class="line"><a name="l01656"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a833e91611ebf3e222d9ea77c288a5d3c"> 1656</a></span>&#160;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a833e91611ebf3e222d9ea77c288a5d3c">DistributedMutex&lt;Atomic, TimePublishing&gt;::try_lock_until</a>(</div>
<div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;    <span class="keyword">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; deadline) {</div>
<div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;  <span class="comment">// fast path for the uncontended case</span></div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;  <span class="comment">// we get the time after trying to acquire the mutex because in the</span></div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;  <span class="comment">// uncontended case, the price of getting the time is about 1/3 of the</span></div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;  <span class="comment">// actual mutex acquisition.  So we only pay the price of that extra bit of</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;  <span class="comment">// latency when needed</span></div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;  <span class="comment">// this is even higher when VDSO is involved on architectures that do not</span></div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;  <span class="comment">// offer a direct interface to the timestamp counter</span></div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> state = try_lock()) {</div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;    <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;  }</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160; </div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;  <span class="comment">// fall back to the timed locking algorithm</span></div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;  <span class="keyword">using</span> Proxy = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>;</div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;  <span class="keywordflow">return</span> timedLock(</div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;      state_,</div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;      deadline,</div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;      [](<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* next, std::uintptr_t expected, <span class="keywordtype">bool</span> timedWaiter) {</div>
<div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;        <span class="keywordflow">return</span> Proxy{next, expected, timedWaiter};</div>
<div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;      });</div>
<div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;}</div>
<div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160; </div>
<div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Atomic, <span class="keywordtype">bool</span> TimePublishing&gt;</div>
<div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</div>
<div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="keyword">typename</span> <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutex&lt;Atomic, TimePublishing&gt;::DistributedMutexStateProxy</a></div>
<div class="line"><a name="l01684"></a><span class="lineno"><a class="line" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9"> 1684</a></span>&#160;<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9">DistributedMutex&lt;Atomic, TimePublishing&gt;::try_lock_for</a>(</div>
<div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;    <span class="keyword">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; duration) {</div>
<div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;  <span class="comment">// fast path for the uncontended case.  Reasoning for doing this here is the</span></div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;  <span class="comment">// same as in try_lock_until()</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> state = try_lock()) {</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;    <span class="keywordflow">return</span> state;</div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;  }</div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160; </div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;  <span class="comment">// fall back to the timed locking algorithm</span></div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;  <span class="keyword">using</span> Proxy = <a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">DistributedMutexStateProxy</a>;</div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;  <span class="keyword">auto</span> deadline = std::chrono::steady_clock::now() + duration;</div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;  <span class="keywordflow">return</span> timedLock(</div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;      state_,</div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;      deadline,</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;      [](<a class="code" href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">Waiter&lt;Atomic&gt;</a>* next, std::uintptr_t expected, <span class="keywordtype">bool</span> timedWaiter) {</div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;        <span class="keywordflow">return</span> Proxy{next, expected, timedWaiter};</div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;      });</div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;}</div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;} <span class="comment">// namespace distributed_mutex</span></div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;} <span class="comment">// namespace detail</span></div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;} <span class="comment">// namespace folly</span></div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a85c5d1b40693aa78f4d57f97a9cdea25"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a85c5d1b40693aa78f4d57f97a9cdea25">folly::detail::distributed_mutex::DistributedMutex::lock</a></div><div class="ttdeci">DistributedMutexStateProxy lock()</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:1090</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html">folly::detail::distributed_mutex::RequestWithReturn</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:359</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_acf4f202428ece047e471c81c2d6920ed"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#acf4f202428ece047e471c81c2d6920ed">folly::detail::distributed_mutex::DistributedMutex::try_lock</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock()</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:1115</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithCoalesce.html">folly::detail::distributed_mutex::TaskWithCoalesce</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:467</div></div>
<div class="ttc" id="astructfolly_1_1detail_1_1distributed__mutex_1_1Sizeof___html"><div class="ttname"><a href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof__.html">folly::detail::distributed_mutex::Sizeof_</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:548</div></div>
<div class="ttc" id="astructfolly_1_1Unit_html"><div class="ttname"><a href="structfolly_1_1Unit.html">folly::Unit</a></div><div class="ttdef"><b>Definition:</b> Unit.h:25</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_1_1DistributedMutexStateProxy.html">folly::detail::distributed_mutex::DistributedMutex::DistributedMutexStateProxy</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:753</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_aea758280455d5d54df56c2fa1919e4bf"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#aea758280455d5d54df56c2fa1919e4bf">folly::detail::distributed_mutex::DistributedMutex::DistributedMutex</a></div><div class="ttdeci">DistributedMutex()</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:846</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html">folly::detail::distributed_mutex::DistributedMutex</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex.h:129</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1WakerMetadata.html">folly::detail::distributed_mutex::WakerMetadata</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:153</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a833e91611ebf3e222d9ea77c288a5d3c"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a833e91611ebf3e222d9ea77c288a5d3c">folly::detail::distributed_mutex::DistributedMutex::try_lock_until</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock_until(const std::chrono::time_point&lt; Clock, Duration &gt; &amp;deadline)</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:1656</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn_html_a6bd39a45c63e30b809e89aaf7ea09006"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a6bd39a45c63e30b809e89aaf7ea09006">folly::detail::distributed_mutex::RequestWithReturn::~RequestWithReturn</a></div><div class="ttdeci">~RequestWithReturn()</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:375</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_ad1a3d59dfd50175ad8de0d0ed97d34f9"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ad1a3d59dfd50175ad8de0d0ed97d34f9">folly::detail::distributed_mutex::DistributedMutex::try_lock_for</a></div><div class="ttdeci">DistributedMutexStateProxy try_lock_for(const std::chrono::duration&lt; Rep, Period &gt; &amp;duration)</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:1684</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1Waiter_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1Waiter.html">folly::detail::distributed_mutex::Waiter</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:213</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithBigReturnValue.html">folly::detail::distributed_mutex::TaskWithBigReturnValue</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:504</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_ac64302904ce02bc0f284cff945ea4f87"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#ac64302904ce02bc0f284cff945ea4f87">folly::detail::distributed_mutex::DistributedMutex::unlock</a></div><div class="ttdeci">void unlock(DistributedMutexStateProxy)</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:1530</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn_html_af2f50de7ca9cafad035e5d5c99673b6b"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html#af2f50de7ca9cafad035e5d5c99673b6b">folly::detail::distributed_mutex::RequestWithoutReturn::get</a></div><div class="ttdeci">void get() &amp;&amp;</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:423</div></div>
<div class="ttc" id="astructfolly_1_1detail_1_1distributed__mutex_1_1Sizeof_html"><div class="ttname"><a href="structfolly_1_1detail_1_1distributed__mutex_1_1Sizeof.html">folly::detail::distributed_mutex::Sizeof</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:554</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1TaskWithoutCoalesce.html">folly::detail::distributed_mutex::TaskWithoutCoalesce</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:489</div></div>
<div class="ttc" id="aclassMetadata_html"><div class="ttname"><a href="classMetadata.html">Metadata</a></div><div class="ttdoc">File metadata to be stored in and retrieved from the RocksDB database.</div><div class="ttdef"><b>Definition:</b> metadata.hpp:35</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn_html"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithoutReturn.html">folly::detail::distributed_mutex::RequestWithoutReturn</a></div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:413</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex_html_a9870e8ffbfa7851f4512c24ccb8c57eb"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1DistributedMutex.html#a9870e8ffbfa7851f4512c24ccb8c57eb">folly::detail::distributed_mutex::DistributedMutex::lock_combine</a></div><div class="ttdeci">auto lock_combine(Task task) -&gt; decltype(std::declval&lt; const Task &amp; &gt;()())</div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1InlineFunctionRef_html"><div class="ttname"><a href="classfolly_1_1detail_1_1InlineFunctionRef.html">folly::detail::InlineFunctionRef&lt; void(), 48 &gt;</a></div></div>
<div class="ttc" id="aclassfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn_html_a8a5a64f50deec551cc048b7e6760aca8"><div class="ttname"><a href="classfolly_1_1detail_1_1distributed__mutex_1_1RequestWithReturn.html#a8a5a64f50deec551cc048b7e6760aca8">folly::detail::distributed_mutex::RequestWithReturn::get</a></div><div class="ttdeci">ReturnType get() &amp;&amp;</div><div class="ttdef"><b>Definition:</b> DistributedMutex-inl.h:382</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
